program Boogie;

var count: int;

procedure square(x : int) returns (ret : int)
spec {
  modifies count;
}
{
  // global declaration
  count := count + 1;
  ret := (x * x);
};

// Generated by an LLM:

procedure sum_1_to_n(n: int) returns (ret: int)
spec {
    requires n >= 0;
    ensures ((n * (n + 1)) div 2) == ret;
}
{
    var i: int;
    var s: int;
    
    i := 0;
    s := 0;

    while (i < n + 1)
    invariant 0 <= i && i <= (n + 1) && s == i * (i - 1) div 2;
    {
        s := s + i;
        i := i + 1;
    }

    assert [sum_eq]: ((n * (n + 1)) div 2) == s;
    ret := s;
};